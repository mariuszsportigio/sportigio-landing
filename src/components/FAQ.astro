---
import {
  defaultLanguage,
  getTranslations,
  type Language,
} from "../i18n";

type FAQItem = {
  question: string;
  answer: string;
};

interface Props {
  lang?: Language;
  title?: string;
  subtitle?: string;
  items?: FAQItem[] | Record<string, FAQItem>;
}

const {
  lang = defaultLanguage,
  title: titleProp,
  subtitle: subtitleProp,
  items: itemsProp,
} = Astro.props as Props;

const translations = getTranslations(lang) as any;
const fallbackTranslations =
  lang === defaultLanguage ? translations : (getTranslations(defaultLanguage) as any);

const landingFaq = translations?.landing?.faq ?? {};
const fallbackFaq = fallbackTranslations?.landing?.faq ?? {};

const title =
  titleProp ??
  landingFaq?.title ??
  fallbackFaq?.title ??
  (lang === defaultLanguage
    ? "Często zadawane pytania"
    : "Frequently asked questions");

const subtitle =
  subtitleProp ??
  landingFaq?.subtitle ??
  fallbackFaq?.subtitle ??
  (lang === defaultLanguage
    ? "Znajdź odpowiedzi na najczęściej zadawane pytania o Sportigio"
    : "Find answers to the most common questions about Sportigio");

const normalizeItems = (value: any): FAQItem[] => {
  if (Array.isArray(value)) {
    return value
      .map((item) => ({
        question: String(item?.question ?? ""),
        answer: String(item?.answer ?? ""),
      }))
      .filter((item) => item.question && item.answer);
  }
  if (value && typeof value === "object") {
    return Object.values(value)
      .map((item: any) => ({
        question: String(item?.question ?? ""),
        answer: String(item?.answer ?? ""),
      }))
      .filter((item) => item.question && item.answer);
  }
  return [];
};

const baseItems = itemsProp ?? landingFaq?.items ?? fallbackFaq?.items ?? [];

const items = (() => {
  const normalized = normalizeItems(baseItems);
  if (normalized.length > 0) return normalized;
  const fallbackNormalized = normalizeItems(fallbackFaq?.items ?? []);
  if (fallbackNormalized.length > 0) return fallbackNormalized;
  return normalizeItems([
    {
      question: "Jak szybko mogę uruchomić Sportigio?",
      answer:
        "Wszystko zależy od Ciebie - samodzielne uruchomienie trwa kilka godzin, a jeśli potrzebujesz naszej pomocy, zrobimy to w kilka dni.",
    },
    {
      question: "Czy mogę zrezygnować w dowolnym momencie?",
      answer:
        "Tak, nasz model abonamentowy pozwala Ci zakończyć współpracę w dowolnej chwili, bez zobowiązań.",
    },
  ]);
})();

const midpoint = Math.ceil(items.length / 2);
const columns: FAQItem[][] =
  items.length <= 3
    ? [items]
    : [items.slice(0, midpoint), items.slice(midpoint)];
---

<section id="faq" class="py-12 bg-white">
  <div class="max-w-5xl mx-auto px-4">
    <div class="text-center mb-8">
      <h2 class="text-2xl lg:text-3xl font-black text-gray-900 mb-2 font-poppins">
        {title}
      </h2>
      <p class="text-base text-gray-600">{subtitle}</p>
    </div>

    <div
      class="grid gap-4"
      class:list={{ "lg:grid-cols-2": columns.length > 1 }}
    >
      {
        columns.map((column, columnIndex) => (
          <div class="flex flex-col gap-4">
            {
              column.map((item, itemIndex) => (
                <div
                  class="faq-item bg-white rounded-lg shadow-sm border border-gray-200"
                  data-faq-item={`${columnIndex}-${itemIndex}`}
                >
                  <button
                    class="faq-question w-full p-4 text-left flex items-center justify-between hover:bg-gray-50 transition-colors rounded-lg"
                  >
                    <span class="text-sm font-semibold text-gray-900">
                      {item.question}
                    </span>
                    <svg
                      class="faq-icon w-4 h-4 text-gray-500 transform transition-transform duration-150 ease-out"
                      fill="none"
                      stroke="currentColor"
                      viewBox="0 0 24 24"
                    >
                      <path
                        stroke-linecap="round"
                        stroke-linejoin="round"
                        stroke-width="2"
                        d="M19 9l-7 7-7-7"
                      ></path>
                    </svg>
                  </button>
                  <div class="faq-answer px-4 pb-4" data-state="closed">
                    <p class="text-sm text-gray-600 leading-relaxed">
                      {item.answer}
                    </p>
                  </div>
                </div>
              ))
            }
          </div>
        ))
      }
    </div>
  </div>
</section>

<script>
  // FAQ Accordion: one open at a time with smooth ease-out animation
  document.addEventListener("DOMContentLoaded", function () {
    const faqItems: HTMLElement[] = Array.from(
      document.querySelectorAll<HTMLElement>(".faq-item"),
    );
    const faqQuestions =
      document.querySelectorAll<HTMLButtonElement>(".faq-question");

    // Equalize header heights so all cards are the same height when closed
    const equalizeQuestionHeights = (): void => {
      let maxHeight = 0;
      // Reset first to measure natural heights
      faqQuestions.forEach((btn) => {
        (btn as HTMLButtonElement).style.minHeight = "";
      });
      faqQuestions.forEach((btn) => {
        const h = (btn as HTMLButtonElement).getBoundingClientRect().height;
        if (h > maxHeight) maxHeight = h;
      });
      const target = Math.ceil(maxHeight);
      faqQuestions.forEach((btn) => {
        (btn as HTMLButtonElement).style.minHeight = `${target}px`;
      });
    };

    function closeItem(item: HTMLElement) {
      const answer = item.querySelector<HTMLElement>(".faq-answer");
      const icon = item.querySelector<SVGElement>(".faq-icon");
      if (!answer) return;
      const state = answer.getAttribute("data-state");
      if (state === "closed" || state === "closing") return;

      answer.setAttribute("data-state", "closing");
      // Prepare from current natural height to 0
      answer.style.height = answer.scrollHeight + "px";
      // Force reflow before shrinking
      void answer.offsetHeight;
      answer.style.height = "0px";
      answer.style.opacity = "0";
      if (icon) (icon as SVGElement).style.transform = "rotate(0deg)";

      const onEnd = (e: TransitionEvent) => {
        if (e.propertyName !== "height") return;
        answer.removeEventListener("transitionend", onEnd);
        answer.setAttribute("data-state", "closed");
        // Keep inline height cleared; base CSS holds height: 0
        answer.style.height = "";
      };
      answer.addEventListener("transitionend", onEnd);
    }

    function openItem(item: HTMLElement) {
      const answer = item.querySelector<HTMLElement>(".faq-answer");
      const icon = item.querySelector<SVGElement>(".faq-icon");
      if (!answer) return;
      const state = answer.getAttribute("data-state");
      if (state === "open" || state === "opening") return;

      answer.setAttribute("data-state", "opening");
      // Ensure start from 0
      answer.style.height = "0px";
      answer.style.opacity = "1";
      // Force reflow then expand to content height
      void answer.offsetHeight;
      const target = answer.scrollHeight;
      answer.style.height = target + "px";
      if (icon) (icon as SVGElement).style.transform = "rotate(180deg)";

      const onEnd = (e: TransitionEvent) => {
        if (e.propertyName !== "height") return;
        answer.removeEventListener("transitionend", onEnd);
        answer.setAttribute("data-state", "open");
        // Allow content to grow naturally after animation
        answer.style.height = "auto";
      };
      answer.addEventListener("transitionend", onEnd);
    }

    // Initialize all answers as closed visually
    faqItems.forEach((item) => {
      const answer = item.querySelector<HTMLElement>(".faq-answer");
      if (!answer) return;
      const state = answer.getAttribute("data-state") || "closed";
      answer.setAttribute("data-state", state);
      if (state === "open") {
        answer.style.height = "auto";
        answer.style.opacity = "1";
      } else {
        answer.style.height = "0px";
        answer.style.opacity = "0";
      }
    });

    faqQuestions.forEach((question) => {
      question.addEventListener("click", () => {
        const currentItem = question.closest(".faq-item") as HTMLElement | null;
        if (!currentItem) return;
        const currentAnswer =
          currentItem.querySelector<HTMLElement>(".faq-answer");
        if (!currentAnswer) return;
        const willOpen = currentAnswer.getAttribute("data-state") !== "open";

        // Close all other items
        faqItems.forEach((item) => {
          if (item !== currentItem) closeItem(item);
        });

        // Toggle current
        if (willOpen) openItem(currentItem);
        else closeItem(currentItem);
        // Recalculate header heights in case line wraps changed after toggle
        equalizeQuestionHeights();
      });
    });

    // Run once after init and on window resize (debounced)
    equalizeQuestionHeights();
    let resizeTimeout: number | undefined;
    window.addEventListener("resize", () => {
      if (resizeTimeout) window.clearTimeout(resizeTimeout);
      resizeTimeout = window.setTimeout(equalizeQuestionHeights, 120);
    });
  });
</script>

<style>
  /* Smooth accordion animation using height + opacity with ease-out */
  .faq-answer {
    overflow: hidden;
    height: 0;
    opacity: 0;
    transition:
      height 140ms ease-out,
      opacity 120ms ease-out,
      padding-bottom 120ms ease-out;
  }

  .faq-answer[data-state="open"],
  .faq-answer[data-state="opening"] {
    opacity: 1;
    padding-bottom: 1rem; /* pb-4 */
  }

  .faq-answer[data-state="closed"],
  .faq-answer[data-state="closing"] {
    opacity: 0;
    padding-bottom: 0; /* collapse vertical spacing when closed */
  }
</style>
